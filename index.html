<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Platformer Odyssey</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #87ceeb;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Combo: <span id="combo">0</span></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Constants
        const GRAVITY = 0.6;
        const FRICTION = 0.9;
        const JUMP_FORCE = -12;
        const MOVE_SPEED = 6;
        const WORLD_WIDTH = 2400;
        const WORLD_HEIGHT = 600;

        // Camera
        const camera = { x: 0, y: 0, follow: (x) => {
            camera.x = Math.max(0, Math.min(x - canvas.width / 2, WORLD_WIDTH - canvas.width));
        }};

        // Player
        const player = {
            x: 100, y: 400, vx: 0, vy: 0,
            width: 40, height: 40,
            grounded: false, jumping: false,
            frame: 0, direction: 1,
            state: 'idle', combo: 0, invulnerable: 0
        };

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Game state
        let gameState = 'start';
        let score = 0;
        let lives = 3;
        let currentLevel = 0;

        // Level data
        const levels = [
            {
                background: [
                    { x: 0, y: 0, width: WORLD_WIDTH, height: WORLD_HEIGHT, speed: 0, color: '#87ceeb' }, // Sky
                    { x: 0, y: 400, width: WORLD_WIDTH, height: 200, speed: 0.2, color: '#6b8e23' }, // Hills
                    { x: 0, y: 500, width: WORLD_WIDTH, height: 100, speed: 0.5, color: '#8b4513' }  // Ground
                ],
                platforms: [
                    { x: 0, y: 550, width: WORLD_WIDTH, height: 50, type: 'ground' },
                    { x: 200, y: 400, width: 150, height: 20, type: 'platform' },
                    { x: 400, y: 300, width: 100, height: 20, type: 'moving', yMin: 200, yMax: 400, vy: 2 },
                    { x: 600, y: 450, width: 120, height: 20, type: 'disappearing', timer: 0 }
                ],
                coins: [
                    { x: 250, y: 350, frame: 0, collected: false },
                    { x: 450, y: 250, frame: 0, collected: false },
                    { x: 700, y: 400, frame: 0, collected: false }
                ],
                enemies: [
                    { type: 'walker', x: 800, y: 510, vx: -2, minX: 700, maxX: 900, frame: 0 },
                    { type: 'flyer', x: 1000, y: 200, vx: 0, vy: 2, minY: 150, maxY: 300, frame: 0 }
                ],
                hazards: [
                    { x: 1200, y: 510, width: 100, height: 40, type: 'spikes' }
                ]
            },
            {
                background: [
                    { x: 0, y: 0, width: WORLD_WIDTH, height: WORLD_HEIGHT, speed: 0, color: '#4682b4' },
                    { x: 0, y: 450, width: WORLD_WIDTH, height: 150, speed: 0.2, color: '#2f4f4f' },
                    { x: 0, y: 550, width: WORLD_WIDTH, height: 50, speed: 0.5, color: '#696969' }
                ],
                platforms: [
                    { x: 0, y: 550, width: WORLD_WIDTH, height: 50, type: 'ground' },
                    { x: 300, y: 350, width: 200, height: 20, type: 'platform' },
                    { x: 600, y: 250, width: 150, height: 20, type: 'moving', yMin: 150, yMax: 350, vy: -2 },
                    { x: 900, y: 400, width: 100, height: 20, type: 'disappearing', timer: 0 }
                ],
                coins: [
                    { x: 350, y: 300, frame: 0, collected: false },
                    { x: 650, y: 200, frame: 0, collected: false },
                    { x: 950, y: 350, frame: 0, collected: false }
                ],
                enemies: [
                    { type: 'walker', x: 1200, y: 510, vx: 3, minX: 1100, maxX: 1300, frame: 0 },
                    { type: 'flyer', x: 1400, y: 300, vx: 0, vy: -3, minY: 200, maxY: 400, frame: 0 }
                ],
                hazards: [
                    { x: 1600, y: 510, width: 150, height: 40, type: 'spikes' }
                ]
            }
        ];

        let gameObjects = { platforms: [], coins: [], enemies: [], hazards: [], background: [] };

        // Load level
        function loadLevel(index) {
            const level = levels[index];
            gameObjects.background = level.background.map(bg => ({ ...bg }));
            gameObjects.platforms = level.platforms.map(p => ({ ...p }));
            gameObjects.coins = level.coins.map(c => ({ ...c }));
            gameObjects.enemies = level.enemies.map(e => ({ ...e }));
            gameObjects.hazards = level.hazards.map(h => ({ ...h }));
            player.x = 100;
            player.y = 400;
            player.vx = 0;
            player.vy = 0;
            player.combo = 0;
            camera.x = 0;
        }

        // Initialize game
        function init() {
            currentLevel = 0;
            loadLevel(currentLevel);
            score = 0;
            lives = 3;
            gameState = 'start';
        }

        // Collision detection
        function collides(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        // Update game
        function update(timestamp) {
            if (gameState !== 'playing') return;

            // Player movement
            player.vx *= FRICTION;
            if (keys['ArrowLeft']) { player.vx = -MOVE_SPEED; player.direction = -1; player.state = 'run'; }
            else if (keys['ArrowRight']) { player.vx = MOVE_SPEED; player.direction = 1; player.state = 'run'; }
            else if (player.grounded) player.state = 'idle';

            if (keys['Space'] && player.grounded && !player.jumping) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                player.jumping = true;
                player.state = 'jump';
            }
            if (!keys['Space']) player.jumping = false;

            player.vy += GRAVITY;
            player.x += player.vx;
            player.y += player.vy;

            // Animation frame
            player.frame = (player.frame + 0.1) % 4;

            // Platform collisions
            player.grounded = false;
            for (let p of gameObjects.platforms) {
                if (collides(player, p)) {
                    if (player.vy > 0 && player.y + player.height - player.vy <= p.y) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.grounded = true;
                    } else if (player.vy < 0 && player.y - player.vy >= p.y + p.height) {
                        player.y = p.y + p.height;
                        player.vy = 0;
                    }
                }
                if (p.type === 'moving') {
                    p.y += p.vy;
                    if (p.y < p.yMin || p.y > p.yMax) p.vy *= -1;
                }
                if (p.type === 'disappearing' && collides(player, p) && p.timer === 0) {
                    p.timer = 60;
                }
                if (p.timer > 0) {
                    p.timer--;
                    if (p.timer === 0) gameObjects.platforms = gameObjects.platforms.filter(plat => plat !== p);
                }
            }

            // Coin collection
            for (let i = gameObjects.coins.length - 1; i >= 0; i--) {
                let coin = gameObjects.coins[i];
                coin.frame = (coin.frame + 0.1) % 4;
                if (collides(player, { x: coin.x, y: coin.y, width: 20, height: 20 }) && !coin.collected) {
                    coin.collected = true;
                    score += 10 + player.combo * 5;
                    player.combo++;
                    gameObjects.coins.splice(i, 1);
                }
            }

            // Enemy updates
            for (let e of gameObjects.enemies) {
                e.frame = (e.frame + 0.1) % 4;
                if (e.type === 'walker') {
                    e.x += e.vx;
                    if (e.x < e.minX || e.x > e.maxX) e.vx *= -1;
                } else if (e.type === 'flyer') {
                    e.y += e.vy;
                    if (e.y < e.minY || e.y > e.maxY) e.vy *= -1;
                }
                if (collides(player, { x: e.x, y: e.y, width: 30, height: 30 }) && player.invulnerable === 0) {
                    lives--;
                    player.invulnerable = 60;
                    player.x = 100;
                    player.y = 400;
                    player.vx = 0;
                    player.vy = 0;
                    player.combo = 0;
                    if (lives <= 0) gameState = 'game over';
                }
            }

            // Hazard collisions
            for (let h of gameObjects.hazards) {
                if (collides(player, h) && player.invulnerable === 0) {
                    lives--;
                    player.invulnerable = 60;
                    player.x = 100;
                    player.y = 400;
                    player.vx = 0;
                    player.vy = 0;
                    player.combo = 0;
                    if (lives <= 0) gameState = 'game over';
                }
            }

            // Level completion
            if (gameObjects.coins.length === 0) {
                currentLevel++;
                if (currentLevel < levels.length) {
                    loadLevel(currentLevel);
                } else {
                    gameState = 'win';
                }
            }

            // Boundaries
            player.x = Math.max(0, Math.min(player.x, WORLD_WIDTH - player.width));
            if (player.y > WORLD_HEIGHT) {
                lives--;
                player.x = 100;
                player.y = 400;
                player.vx = 0;
                player.vy = 0;
                if (lives <= 0) gameState = 'game over';
            }

            // Update invulnerability
            if (player.invulnerable > 0) player.invulnerable--;

            // Update camera
            camera.follow(player.x);

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = currentLevel + 1;
            document.getElementById('combo').textContent = player.combo;
        }

        // Draw game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'start') {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Press Space to Begin', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw background with parallax
            for (let bg of gameObjects.background) {
                ctx.fillStyle = bg.color;
                let bgX = -(camera.x * bg.speed) % bg.width;
                ctx.fillRect(bgX, bg.y, bg.width, bg.height);
                if (bgX < 0) ctx.fillRect(bgX + bg.width, bg.y, bg.width, bg.height);
            }

            // Draw platforms
            for (let p of gameObjects.platforms) {
                ctx.fillStyle = p.type === 'disappearing' && p.timer > 0 ? 'orange' : 'green';
                ctx.fillRect(p.x - camera.x, p.y - camera.y, p.width, p.height);
            }

            // Draw coins
            ctx.fillStyle = 'gold';
            for (let c of gameObjects.coins) {
                if (!c.collected) {
                    let size = 20 + Math.sin(c.frame) * 5;
                    ctx.fillRect(c.x - camera.x - size / 2, c.y - camera.y - size / 2, size, size);
                }
            }

            // Draw enemies
            for (let e of gameObjects.enemies) {
                ctx.fillStyle = e.type === 'walker' ? 'purple' : 'red';
                ctx.fillRect(e.x - camera.x, e.y - camera.y, 30, 30);
            }

            // Draw hazards
            ctx.fillStyle = 'gray';
            for (let h of gameObjects.hazards) {
                ctx.fillRect(h.x - camera.x, h.y - camera.y, h.width, h.height);
            }

            // Draw player
            ctx.fillStyle = player.invulnerable > 0 && Math.floor(player.invulnerable / 5) % 2 === 0 ? 'gray' : 'blue';
            ctx.fillRect(player.x - camera.x, player.y - camera.y, player.width, player.height);

            // Game over or win screen
            if (gameState === 'game over') {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText('Press Space to Restart', canvas.width / 2, canvas.height / 2 + 50);
            } else if (gameState === 'win') {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Victory!', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText('Press Space to Replay', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            if (gameState === 'start' && keys['Space']) gameState = 'playing';
            if ((gameState === 'game over' || gameState === 'win') && keys['Space']) init();
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
