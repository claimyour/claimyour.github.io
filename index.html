<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Legends: Shadow Realm</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #111;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 2px solid #444;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #inventory, #quests {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Health: <span id="health">100</span>/<span id="maxHealth">100</span></div>
        <div>Mana: <span id="mana">50</span>/<span id="maxMana">50</span></div>
        <div>Gold: <span id="gold">0</span></div>
        <div>Level: <span id="level">1</span> (XP: <span id="xp">0</span>/<span id="xpNext">100</span>)</div>
        <div id="inventory">Inventory: <span id="items">-</span></div>
        <div id="quests">Quests: <span id="questList">-</span></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Constants
        const TILE_SIZE = 32;
        const WORLD_WIDTH = 50;
        const WORLD_HEIGHT = 50;
        const MOVE_SPEED = 4;
        const ATTACK_RANGE = 50;

        // Game state
        let gameState = 'start';
        let player = {
            x: WORLD_WIDTH * TILE_SIZE / 2,
            y: WORLD_HEIGHT * TILE_SIZE / 2,
            width: 24, height: 24,
            vx: 0, vy: 0,
            health: 100, maxHealth: 100,
            mana: 50, maxMana: 50,
            gold: 0, level: 1, xp: 0, xpNext: 100,
            inventory: [],
            quests: [{ name: 'Slay 5 Goblins', type: 'kill', target: 'goblin', goal: 5, progress: 0 }],
            attackCooldown: 0, frame: 0, direction: 'down'
        };

        // Input
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Camera
        const camera = {
            x: 0, y: 0,
            update: () => {
                camera.x = Math.max(0, Math.min(player.x - canvas.width / 2, WORLD_WIDTH * TILE_SIZE - canvas.width));
                camera.y = Math.max(0, Math.min(player.y - canvas.height / 2, WORLD_HEIGHT * TILE_SIZE - canvas.height));
            }
        };

        // Procedural dungeon generation
        function generateDungeon() {
            let map = Array(WORLD_HEIGHT).fill().map(() => Array(WORLD_WIDTH).fill('wall'));
            function carveRoom(x, y, w, h) {
                for (let i = y; i < y + h; i++) {
                    for (let j = x; j < x + w; j++) {
                        if (i >= 0 && i < WORLD_HEIGHT && j >= 0 && j < WORLD_WIDTH) map[i][j] = 'floor';
                    }
                }
            }
            function carveCorridor(x1, y1, x2, y2) {
                for (let i = Math.min(y1, y2); i <= Math.max(y1, y2); i++) {
                    if (i >= 0 && i < WORLD_HEIGHT) map[i][x1] = 'floor';
                }
                for (let j = Math.min(x1, x2); j <= Math.max(x1, x2); j++) {
                    if (y1 >= 0 && y1 < WORLD_HEIGHT) map[y1][j] = 'floor';
                }
            }

            let rooms = [];
            for (let i = 0; i < 10; i++) {
                let w = 5 + Math.floor(Math.random() * 5);
                let h = 5 + Math.floor(Math.random() * 5);
                let x = Math.floor(Math.random() * (WORLD_WIDTH - w));
                let y = Math.floor(Math.random() * (WORLD_HEIGHT - h));
                carveRoom(x, y, w, h);
                rooms.push({ x: x + w / 2, y: y + h / 2 });
            }
            for (let i = 1; i < rooms.length; i++) {
                carveCorridor(Math.floor(rooms[i-1].x), Math.floor(rooms[i-1].y), Math.floor(rooms[i].x), Math.floor(rooms[i].y));
            }
            return map;
        }

        let map = generateDungeon();
        let entities = [];

        // Entity types
        const entityTypes = {
            goblin: { health: 20, damage: 5, speed: 2, color: 'green', xp: 10, drops: ['gold', 'potion'] },
            skeleton: { health: 30, damage: 8, speed: 1.5, color: 'gray', xp: 15, drops: ['gold', 'bone'] },
            chest: { health: 1, damage: 0, speed: 0, color: 'brown', xp: 0, drops: ['gold', 'sword', 'potion'] }
        };

        // Spawn entities
        function spawnEntities() {
            entities = [];
            for (let i = 0; i < 10; i++) {
                let x, y;
                do { x = Math.floor(Math.random() * WORLD_WIDTH); y = Math.floor(Math.random() * WORLD_HEIGHT); }
                while (map[y][x] !== 'floor');
                entities.push({
                    type: Math.random() < 0.7 ? 'goblin' : 'skeleton',
                    x: x * TILE_SIZE, y: y * TILE_SIZE,
                    width: 24, height: 24,
                    ...entityTypes[Math.random() < 0.7 ? 'goblin' : 'skeleton'],
                    frame: 0
                });
            }
            for (let i = 0; i < 3; i++) {
                let x, y;
                do { x = Math.floor(Math.random() * WORLD_WIDTH); y = Math.floor(Math.random() * WORLD_HEIGHT); }
                while (map[y][x] !== 'floor');
                entities.push({
                    type: 'chest',
                    x: x * TILE_SIZE, y: y * TILE_SIZE,
                    width: 24, height: 24,
                    ...entityTypes.chest
                });
            }
        }

        // Collision detection
        function collides(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        // Initialize game
        function init() {
            map = generateDungeon();
            spawnEntities();
            player = {
                x: WORLD_WIDTH * TILE_SIZE / 2, y: WORLD_HEIGHT * TILE_SIZE / 2,
                width: 24, height: 24, vx: 0, vy: 0,
                health: 100, maxHealth: 100, mana: 50, maxMana: 50,
                gold: 0, level: 1, xp: 0, xpNext: 100,
                inventory: [], quests: [{ name: 'Slay 5 Goblins', type: 'kill', target: 'goblin', goal: 5, progress: 0 }],
                attackCooldown: 0, frame: 0, direction: 'down'
            };
            gameState = 'start';
        }

        // Update game
        function update(timestamp) {
            if (gameState !== 'playing') return;

            // Player movement
            player.vx = 0;
            player.vy = 0;
            if (keys['KeyW']) { player.vy = -MOVE_SPEED; player.direction = 'up'; }
            if (keys['KeyS']) { player.vy = MOVE_SPEED; player.direction = 'down'; }
            if (keys['KeyA']) { player.vx = -MOVE_SPEED; player.direction = 'left'; }
            if (keys['KeyD']) { player.vx = MOVE_SPEED; player.direction = 'right'; }

            let nextX = player.x + player.vx;
            let nextY = player.y + player.vy;
            if (nextX >= 0 && nextX <= WORLD_WIDTH * TILE_SIZE - player.width && 
                map[Math.floor(nextY / TILE_SIZE)][Math.floor(nextX / TILE_SIZE)] !== 'wall' &&
                map[Math.floor((nextY + player.height - 1) / TILE_SIZE)][Math.floor((nextX + player.width - 1) / TILE_SIZE)] !== 'wall') {
                player.x = nextX;
                player.y = nextY;
            }

            player.frame = player.vx !== 0 || player.vy !== 0 ? (player.frame + 0.1) % 4 : 0;

            // Attack
            if (keys['Space'] && player.attackCooldown === 0) {
                player.attackCooldown = 20;
                for (let e of entities) {
                    let dx = e.x - player.x;
                    let dy = e.y - player.y;
                    if (Math.sqrt(dx * dx + dy * dy) < ATTACK_RANGE) {
                        e.health -= 10 + player.level * 2;
                        if (e.health <= 0) {
                            if (e.type !== 'chest') {
                                player.xp += e.xp;
                                player.gold += Math.floor(Math.random() * 5) + 1;
                                if (e.type === 'goblin') player.quests[0].progress++;
                            }
                            e.drops.forEach(drop => {
                                if (Math.random() < 0.5) player.inventory.push(drop);
                            });
                            entities = entities.filter(ent => ent !== e);
                        }
                    }
                }
            }
            if (player.attackCooldown > 0) player.attackCooldown--;

            // Level up
            if (player.xp >= player.xpNext) {
                player.level++;
                player.xp -= player.xpNext;
                player.xpNext *= 1.5;
                player.maxHealth += 20;
                player.health = player.maxHealth;
                player.maxMana += 10;
                player.mana = player.maxMana;
            }

            // Quest completion
            if (player.quests[0].progress >= player.quests[0].goal) {
                player.gold += 50;
                player.xp += 50;
                player.quests = [];
            }

            // Enemy AI
            for (let e of entities) {
                if (e.type !== 'chest') {
                    e.frame = (e.frame + 0.1) % 4;
                    let dx = player.x - e.x;
                    let dy = player.y - e.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                        if (collides(player, e) && player.attackCooldown === 0) {
                            player.health -= e.damage;
                            player.attackCooldown = 20;
                            if (player.health <= 0) gameState = 'game over';
                        }
                    }
                }
            }

            // Regenerate mana
            if (player.mana < player.maxMana) player.mana += 0.1;

            // Use inventory items
            if (keys['KeyE'] && player.inventory.includes('potion') && player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 30);
                player.inventory.splice(player.inventory.indexOf('potion'), 1);
            }

            camera.update();

            // Update UI
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('maxHealth').textContent = player.maxHealth;
            document.getElementById('mana').textContent = Math.floor(player.mana);
            document.getElementById('maxMana').textContent = player.maxMana;
            document.getElementById('gold').textContent = player.gold;
            document.getElementById('level').textContent = player.level;
            document.getElementById('xp').textContent = Math.floor(player.xp);
            document.getElementById('xpNext').textContent = Math.floor(player.xpNext);
            document.getElementById('items').textContent = player.inventory.length > 0 ? player.inventory.join(', ') : '-';
            document.getElementById('questList').textContent = player.quests.length > 0 ? 
                `${player.quests[0].name} (${player.quests[0].progress}/${player.quests[0].goal})` : 'None';
        }

        // Draw game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'start') {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Dungeon Legends: Shadow Realm', canvas.width / 2, canvas.height / 2 - 50);
                ctx.font = '24px Arial';
                ctx.fillText('Press Space to Start', canvas.width / 2, canvas.height / 2 + 50);
                return;
            }

            // Draw map
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    let screenX = x * TILE_SIZE - camera.x;
                    let screenY = y * TILE_SIZE - camera.y;
                    if (screenX > -TILE_SIZE && screenX < canvas.width && screenY > -TILE_SIZE && screenY < canvas.height) {
                        ctx.fillStyle = map[y][x] === 'wall' ? '#333' : '#666';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // Draw entities
            for (let e of entities) {
                ctx.fillStyle = e.color;
                ctx.fillRect(e.x - camera.x, e.y - camera.y, e.width, e.height);
            }

            // Draw player
            ctx.fillStyle = player.attackCooldown > 0 ? 'red' : 'blue';
            ctx.fillRect(player.x - camera.x, player.y - camera.y, player.width, player.height);

            // Draw attack range (debug)
            if (player.attackCooldown > 0) {
                ctx.strokeStyle = 'red';
                ctx.beginPath();
                ctx.arc(player.x - camera.x + player.width / 2, player.y - camera.y + player.height / 2, ATTACK_RANGE, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Game over or win
            if (gameState === 'game over') {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText('Press Space to Restart', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            if (gameState === 'start' && keys['Space']) gameState = 'playing';
            if (gameState === 'game over' && keys['Space']) init();
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
